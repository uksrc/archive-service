package org.uksrc.archive.searchrequest.params.descriptors;

import jakarta.persistence.criteria.*;
import org.uksrc.archive.searchrequest.query.QueryContext;
import static org.uksrc.archive.searchrequest.params.parser.FieldRegistry.FieldDefinition;

/**
 * Represents a predicate descriptor for performing a cone search based on spatial coordinates.
 * A cone search is used to filter entities within a certain angular distance from a specific point
 * on a celestial sphere, defined by right ascension (RA), declination (Dec), and a radius. The
 * predicate generated by this descriptor uses JPA's Criteria API and a pgshphere database function
 * for distance computation.
 */
public class ConeSearchDescriptor implements PredicateDescriptor {

    private final FieldDefinition fieldDef;
    private final double ra;     // Degrees
    private final double dec;    // Degrees
    private final double radius; // Degrees

    /**
     * Constructs a ConeSearchDescriptor for defining a spatial filtering criterion using a cone
     * search on a celestial sphere. The cone search is specified by a central point defined
     * through right ascension (RA) and declination (Dec), along with a radius. This descriptor
     * is used to build a predicate for filtering entities within the given angular distance from
     * the central point.
     *
     * @param fieldDef The field definition containing metadata about the entity attribute, including
     *                 the entity path where the spatial coordinate information is stored.
     * @param ra       The right ascension of the central point of the cone, specified in degrees.
     * @param dec      The declination of the central point of the cone, specified in degrees.
     * @param radius   The radius of the cone, defining the angular distance for the search area,
     *                 specified in degrees.
     */
    public ConeSearchDescriptor(FieldDefinition fieldDef, double ra, double dec, double radius) {
        this.fieldDef = fieldDef;
        this.ra = ra;
        this.dec = dec;
        this.radius = radius;
    }

    /**
     * Constructs a JPA {@link Predicate} that represents a spatial filtering condition
     * based on a cone search criterion. This method dynamically builds a predicate
     * to filter entities whose spatial coordinates fall within the specified angular
     * distance (radius) from a given central point (right ascension and declination).
     * <p>
     * The method utilises the PostGIS `pgsphere_distance` function to calculate the
     * angular distance in radians between stored coordinates and the central point.
     * Entities with distances less than or equal to the radius are included in the result.
     *
     * @param context the {@link QueryContext} providing access to the {@link CriteriaBuilder}
     *                and the root entity for constructing the predicate. It includes information
     *                necessary for resolving paths to database attributes and creating required
     *                comparison expressions.
     * @return a {@link Predicate} that filters entities based on the specified cone search
     *         criterion, ensuring that the spatial coordinates are within the defined angular distance.
     */
    @Override
    public Predicate toPredicate(QueryContext<?> context) {
        CriteriaBuilder cb = context.criteriaBuilder();

        // Resolve the path to the coordinate entity (e.g., tp.coordinates)
        Path<?> coordsPath = resolvePath(context.root(), fieldDef.entityPath());

        // Access the coordinate values (cval1 = RA/Lon, cval2 = Dec/Lat)
        // Note: These are usually stored in radians in the pgsphere extended database.
        Expression<Double> raProp = coordsPath.get("cval1").as(Double.class);
        Expression<Double> decProp = coordsPath.get("cval2").as(Double.class);

        // Define the distance function: pgsphere_distance(p1, p2, p3, p4)
        // We pass the parameters as degrees as the pgsphere_distance expects them.
        Expression<Double> distanceFunc = cb.function(
                "pgsphere_distance",
                Double.class,
                raProp,
                decProp,
                cb.literal(ra),
                cb.literal(dec)
        );

        // Compare distance to the radius (converted to radians)
        return cb.lessThanOrEqualTo(distanceFunc, Math.toRadians(radius));
    }
}
